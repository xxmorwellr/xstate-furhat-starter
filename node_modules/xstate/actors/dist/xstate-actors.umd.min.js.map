{"version":3,"file":"xstate-actors.umd.min.js","sources":["../../src/Mailbox.ts","../../src/constants.ts","../../src/dev/index.ts","../../src/reportUnhandledError.ts","../../src/symbolObservable.ts","../../src/utils.ts","../../src/system.ts","../../src/createActor.ts","../../src/eventUtils.ts","../../src/actors/transition.ts","../../src/actors/callback.ts","../../src/actors/observable.ts","../../src/actors/promise.ts","../../src/actors/index.ts"],"sourcesContent":["interface MailboxItem<T> {\n  value: T;\n  next: MailboxItem<T> | null;\n}\n\nexport class Mailbox<T> {\n  private _active: boolean = false;\n  private _current: MailboxItem<T> | null = null;\n  private _last: MailboxItem<T> | null = null;\n\n  constructor(private _process: (ev: T) => void) {}\n\n  public start() {\n    this._active = true;\n    this.flush();\n  }\n\n  public clear(): void {\n    // we can't set _current to null because we might be currently processing\n    // and enqueue following clear shouldnt start processing the enqueued item immediately\n    if (this._current) {\n      this._current.next = null;\n      this._last = this._current;\n    }\n  }\n\n  public enqueue(event: T): void {\n    const enqueued = {\n      value: event,\n      next: null\n    };\n\n    if (this._current) {\n      this._last!.next = enqueued;\n      this._last = enqueued;\n      return;\n    }\n\n    this._current = enqueued;\n    this._last = enqueued;\n\n    if (this._active) {\n      this.flush();\n    }\n  }\n\n  private flush() {\n    while (this._current) {\n      // atm the given _process is responsible for implementing proper try/catch handling\n      // we assume here that this won't throw in a way that can affect this mailbox\n      const consumed = this._current;\n      this._process(consumed.value);\n      this._current = consumed.next;\n    }\n    this._last = null;\n  }\n}\n","export const STATE_DELIMITER = '.';\nexport const TARGETLESS_KEY = '';\nexport const NULL_EVENT = '';\nexport const STATE_IDENTIFIER = '#';\nexport const WILDCARD = '*';\nexport const XSTATE_INIT = 'xstate.init';\nexport const XSTATE_ERROR = 'xstate.error';\nexport const XSTATE_STOP = 'xstate.stop';\n","import isDevelopment from '#is-development';\nimport { AnyActor, DevToolsAdapter } from '../types.ts';\n\ninterface DevInterface {\n  services: Set<AnyActor>;\n  register(service: AnyActor): void;\n  onRegister(listener: ServiceListener): void;\n}\ntype ServiceListener = (service: AnyActor) => void;\n\nexport interface XStateDevInterface {\n  register: (service: AnyActor) => void;\n  unregister: (service: AnyActor) => void;\n  onRegister: (listener: ServiceListener) => {\n    unsubscribe: () => void;\n  };\n  services: Set<AnyActor>;\n}\n\n// From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\nexport function getGlobal(): typeof globalThis | undefined {\n  if (typeof globalThis !== 'undefined') {\n    return globalThis;\n  }\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n  if (typeof window !== 'undefined') {\n    return window;\n  }\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n  if (isDevelopment) {\n    console.warn(\n      'XState could not find a global object in this environment. Please let the maintainers know and raise an issue here: https://github.com/statelyai/xstate/issues'\n    );\n  }\n}\n\nfunction getDevTools(): DevInterface | undefined {\n  const w = getGlobal();\n  if (!!(w as any).__xstate__) {\n    return (w as any).__xstate__;\n  }\n\n  return undefined;\n}\n\nexport function registerService(service: AnyActor) {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n}\n\nexport const devToolsAdapter: DevToolsAdapter = (service) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const devTools = getDevTools();\n\n  if (devTools) {\n    devTools.register(service);\n  }\n};\n","/**\n * This function makes sure that unhandled errors are thrown in a separate\n * macrotask. It allows those errors to be detected by global error handlers and\n * reported to bug tracking services without interrupting our own stack of\n * execution.\n *\n * @param err Error to be thrown\n */\nexport function reportUnhandledError(err: unknown) {\n  setTimeout(() => {\n    throw err;\n  });\n}\n","export const symbolObservable: typeof Symbol.observable = (() =>\n  (typeof Symbol === 'function' && Symbol.observable) ||\n  '@@observable')() as any;\n","import isDevelopment from '#is-development';\nimport { isMachineSnapshot } from './State.ts';\nimport type { StateNode } from './StateNode.ts';\nimport { TARGETLESS_KEY } from './constants.ts';\nimport type {\n  AnyActorLogic,\n  AnyActorRef,\n  AnyEventObject,\n  AnyMachineSnapshot,\n  AnyStateMachine,\n  AnyTransitionConfig,\n  ErrorActorEvent,\n  EventObject,\n  InvokeConfig,\n  MachineContext,\n  Mapper,\n  NonReducibleUnknown,\n  Observer,\n  SingleOrArray,\n  StateLike,\n  StateValue,\n  TransitionConfigTarget\n} from './types.ts';\n\nexport function matchesState(\n  parentStateId: StateValue,\n  childStateId: StateValue\n): boolean {\n  const parentStateValue = toStateValue(parentStateId);\n  const childStateValue = toStateValue(childStateId);\n\n  if (typeof childStateValue === 'string') {\n    if (typeof parentStateValue === 'string') {\n      return childStateValue === parentStateValue;\n    }\n\n    // Parent more specific than child\n    return false;\n  }\n\n  if (typeof parentStateValue === 'string') {\n    return parentStateValue in childStateValue;\n  }\n\n  return Object.keys(parentStateValue).every((key) => {\n    if (!(key in childStateValue)) {\n      return false;\n    }\n\n    return matchesState(parentStateValue[key]!, childStateValue[key]!);\n  });\n}\n\nexport function toStatePath(stateId: string | string[]): string[] {\n  if (isArray(stateId)) {\n    return stateId;\n  }\n\n  let result: string[] = [];\n  let segment = '';\n\n  for (let i = 0; i < stateId.length; i++) {\n    const char = stateId.charCodeAt(i);\n    switch (char) {\n      // \\\n      case 92:\n        // consume the next character\n        segment += stateId[i + 1];\n        // and skip over it\n        i++;\n        continue;\n      // .\n      case 46:\n        result.push(segment);\n        segment = '';\n        continue;\n    }\n    segment += stateId[i];\n  }\n\n  result.push(segment);\n\n  return result;\n}\n\nfunction toStateValue(stateValue: StateLike<any> | StateValue): StateValue {\n  if (isMachineSnapshot(stateValue)) {\n    return stateValue.value;\n  }\n\n  if (typeof stateValue !== 'string') {\n    return stateValue as StateValue;\n  }\n\n  const statePath = toStatePath(stateValue);\n\n  return pathToStateValue(statePath);\n}\n\nexport function pathToStateValue(statePath: string[]): StateValue {\n  if (statePath.length === 1) {\n    return statePath[0];\n  }\n\n  const value: StateValue = {};\n  let marker = value;\n\n  for (let i = 0; i < statePath.length - 1; i++) {\n    if (i === statePath.length - 2) {\n      marker[statePath[i]] = statePath[i + 1];\n    } else {\n      const previous = marker;\n      marker = {};\n      previous[statePath[i]] = marker;\n    }\n  }\n\n  return value;\n}\n\nexport function mapValues<P, O extends Record<string, unknown>>(\n  collection: O,\n  iteratee: (item: O[keyof O], key: keyof O, collection: O, i: number) => P\n): { [key in keyof O]: P };\nexport function mapValues(\n  collection: Record<string, unknown>,\n  iteratee: (\n    item: unknown,\n    key: string,\n    collection: Record<string, unknown>,\n    i: number\n  ) => unknown\n) {\n  const result: Record<string, unknown> = {};\n\n  const collectionKeys = Object.keys(collection);\n  for (let i = 0; i < collectionKeys.length; i++) {\n    const key = collectionKeys[i];\n    result[key] = iteratee(collection[key], key, collection, i);\n  }\n\n  return result;\n}\n\nfunction toArrayStrict<T>(value: readonly T[] | T): readonly T[] {\n  if (isArray(value)) {\n    return value;\n  }\n  return [value];\n}\n\nexport function toArray<T>(value: readonly T[] | T | undefined): readonly T[] {\n  if (value === undefined) {\n    return [];\n  }\n  return toArrayStrict(value);\n}\n\nexport function resolveOutput<\n  TContext extends MachineContext,\n  TExpressionEvent extends EventObject\n>(\n  mapper:\n    | Mapper<TContext, TExpressionEvent, unknown, EventObject>\n    | NonReducibleUnknown,\n  context: TContext,\n  event: TExpressionEvent,\n  self: AnyActorRef\n): unknown {\n  if (typeof mapper === 'function') {\n    return mapper({ context, event, self });\n  }\n\n  if (\n    isDevelopment &&\n    !!mapper &&\n    typeof mapper === 'object' &&\n    Object.values(mapper).some((val) => typeof val === 'function')\n  ) {\n    console.warn(\n      `Dynamically mapping values to individual properties is deprecated. Use a single function that returns the mapped object instead.\\nFound object containing properties whose values are possibly mapping functions: ${Object.entries(\n        mapper\n      )\n        .filter(([key, value]) => typeof value === 'function')\n        .map(\n          ([key, value]) =>\n            `\\n - ${key}: ${(value as () => any)\n              .toString()\n              .replace(/\\n\\s*/g, '')}`\n        )\n        .join('')}`\n    );\n  }\n\n  return mapper;\n}\n\nfunction isArray(value: any): value is readonly any[] {\n  return Array.isArray(value);\n}\n\nexport function isErrorActorEvent(\n  event: AnyEventObject\n): event is ErrorActorEvent {\n  return event.type.startsWith('xstate.error.actor');\n}\n\nexport function toTransitionConfigArray<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  configLike: SingleOrArray<AnyTransitionConfig | TransitionConfigTarget>\n): Array<AnyTransitionConfig> {\n  return toArrayStrict(configLike).map((transitionLike) => {\n    if (\n      typeof transitionLike === 'undefined' ||\n      typeof transitionLike === 'string'\n    ) {\n      return { target: transitionLike };\n    }\n\n    return transitionLike;\n  });\n}\n\nexport function normalizeTarget<\n  TContext extends MachineContext,\n  TEvent extends EventObject\n>(\n  target: SingleOrArray<string | StateNode<TContext, TEvent>> | undefined\n): ReadonlyArray<string | StateNode<TContext, TEvent>> | undefined {\n  if (target === undefined || target === TARGETLESS_KEY) {\n    return undefined;\n  }\n  return toArray(target);\n}\n\nexport function toObserver<T>(\n  nextHandler?: Observer<T> | ((value: T) => void),\n  errorHandler?: (error: any) => void,\n  completionHandler?: () => void\n): Observer<T> {\n  const isObserver = typeof nextHandler === 'object';\n  const self = isObserver ? nextHandler : undefined;\n\n  return {\n    next: (isObserver ? nextHandler.next : nextHandler)?.bind(self),\n    error: (isObserver ? nextHandler.error : errorHandler)?.bind(self),\n    complete: (isObserver ? nextHandler.complete : completionHandler)?.bind(\n      self\n    )\n  };\n}\n\nexport function createInvokeId(stateNodeId: string, index: number): string {\n  return `${index}.${stateNodeId}`;\n}\n\nexport function resolveReferencedActor(machine: AnyStateMachine, src: string) {\n  const match = src.match(/^xstate\\.invoke\\.(\\d+)\\.(.*)/)!;\n  if (!match) {\n    return machine.implementations.actors[src];\n  }\n  const [, indexStr, nodeId] = match;\n  const node = machine.getStateNodeById(nodeId);\n  const invokeConfig = node.config.invoke!;\n  return (\n    Array.isArray(invokeConfig)\n      ? invokeConfig[indexStr as any]\n      : (invokeConfig as InvokeConfig<\n          any,\n          any,\n          any,\n          any,\n          any,\n          any,\n          any, // TEmitted\n          any // TMeta\n        >)\n  ).src;\n}\n\nexport function getAllOwnEventDescriptors(snapshot: AnyMachineSnapshot) {\n  return [...new Set([...snapshot._nodes.flatMap((sn) => sn.ownEvents)])];\n}\n","import { InspectionEvent } from './inspection.ts';\nimport {\n  AnyEventObject,\n  ActorSystemInfo,\n  AnyActorRef,\n  Observer,\n  Snapshot,\n  HomomorphicOmit,\n  EventObject,\n  AnyTransitionDefinition,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\ninterface ScheduledEvent {\n  id: string;\n  event: EventObject;\n  startedAt: number; // timestamp\n  delay: number;\n  source: AnyActorRef;\n  target: AnyActorRef;\n}\n\nexport interface Clock {\n  setTimeout(fn: (...args: any[]) => void, timeout: number): any;\n  clearTimeout(id: any): void;\n}\n\ninterface Scheduler {\n  schedule(\n    source: AnyActorRef,\n    target: AnyActorRef,\n    event: EventObject,\n    delay: number,\n    id: string | undefined\n  ): void;\n  cancel(source: AnyActorRef, id: string): void;\n  cancelAll(actorRef: AnyActorRef): void;\n}\n\ntype ScheduledEventId = string & { __scheduledEventId: never };\n\nfunction createScheduledEventId(\n  actorRef: AnyActorRef,\n  id: string\n): ScheduledEventId {\n  return `${actorRef.sessionId}.${id}` as ScheduledEventId;\n}\n\nexport interface ActorSystem<T extends ActorSystemInfo> {\n  /** @internal */\n  _bookId: () => string;\n  /** @internal */\n  _register: (sessionId: string, actorRef: AnyActorRef) => string;\n  /** @internal */\n  _unregister: (actorRef: AnyActorRef) => void;\n  /** @internal */\n  _set: <K extends keyof T['actors']>(key: K, actorRef: T['actors'][K]) => void;\n  get: <K extends keyof T['actors']>(key: K) => T['actors'][K] | undefined;\n\n  inspect: (\n    observer:\n      | Observer<InspectionEvent>\n      | ((inspectionEvent: InspectionEvent) => void)\n  ) => Subscription;\n  /** @internal */\n  _sendInspectionEvent: (\n    event: HomomorphicOmit<InspectionEvent, 'rootId'>\n  ) => void;\n  /** @internal */\n  _relay: (\n    source: AnyActorRef | undefined,\n    target: AnyActorRef,\n    event: AnyEventObject\n  ) => void;\n  scheduler: Scheduler;\n  getSnapshot: () => {\n    _scheduledEvents: Record<string, ScheduledEvent>;\n  };\n  /** @internal */\n  _snapshot: {\n    _scheduledEvents: Record<ScheduledEventId, ScheduledEvent>;\n  };\n  start: () => void;\n  _clock: Clock;\n  _logger: (...args: any[]) => void;\n}\n\nexport type AnyActorSystem = ActorSystem<any>;\n\nlet idCounter = 0;\nexport function createSystem<T extends ActorSystemInfo>(\n  rootActor: AnyActorRef,\n  options: {\n    clock: Clock;\n    logger: (...args: any[]) => void;\n    snapshot?: unknown;\n  }\n): ActorSystem<T> {\n  const children = new Map<string, AnyActorRef>();\n  const keyedActors = new Map<keyof T['actors'], AnyActorRef | undefined>();\n  const reverseKeyedActors = new WeakMap<AnyActorRef, keyof T['actors']>();\n  const inspectionObservers = new Set<Observer<InspectionEvent>>();\n  const timerMap: { [id: ScheduledEventId]: number } = {};\n  const { clock, logger } = options;\n\n  const scheduler: Scheduler = {\n    schedule: (\n      source,\n      target,\n      event,\n      delay,\n      id = Math.random().toString(36).slice(2)\n    ) => {\n      const scheduledEvent: ScheduledEvent = {\n        source,\n        target,\n        event,\n        delay,\n        id,\n        startedAt: Date.now()\n      };\n      const scheduledEventId = createScheduledEventId(source, id);\n      system._snapshot._scheduledEvents[scheduledEventId] = scheduledEvent;\n\n      const timeout = clock.setTimeout(() => {\n        delete timerMap[scheduledEventId];\n        delete system._snapshot._scheduledEvents[scheduledEventId];\n\n        system._relay(source, target, event);\n      }, delay);\n\n      timerMap[scheduledEventId] = timeout;\n    },\n    cancel: (source, id: string) => {\n      const scheduledEventId = createScheduledEventId(source, id);\n      const timeout = timerMap[scheduledEventId];\n\n      delete timerMap[scheduledEventId];\n      delete system._snapshot._scheduledEvents[scheduledEventId];\n\n      if (timeout !== undefined) {\n        clock.clearTimeout(timeout);\n      }\n    },\n    cancelAll: (actorRef) => {\n      for (const scheduledEventId in system._snapshot._scheduledEvents) {\n        const scheduledEvent =\n          system._snapshot._scheduledEvents[\n            scheduledEventId as ScheduledEventId\n          ];\n        if (scheduledEvent.source === actorRef) {\n          scheduler.cancel(actorRef, scheduledEvent.id);\n        }\n      }\n    }\n  };\n  const sendInspectionEvent = (event: InspectionEvent) => {\n    if (!inspectionObservers.size) {\n      return;\n    }\n    const resolvedInspectionEvent: InspectionEvent = {\n      ...event,\n      rootId: rootActor.sessionId\n    };\n    inspectionObservers.forEach(\n      (observer) => observer.next?.(resolvedInspectionEvent)\n    );\n  };\n\n  const system: ActorSystem<T> = {\n    _snapshot: {\n      _scheduledEvents:\n        (options?.snapshot && (options.snapshot as any).scheduler) ?? {}\n    },\n    _bookId: () => `x:${idCounter++}`,\n    _register: (sessionId, actorRef) => {\n      children.set(sessionId, actorRef);\n      return sessionId;\n    },\n    _unregister: (actorRef) => {\n      children.delete(actorRef.sessionId);\n      const systemId = reverseKeyedActors.get(actorRef);\n\n      if (systemId !== undefined) {\n        keyedActors.delete(systemId);\n        reverseKeyedActors.delete(actorRef);\n      }\n    },\n    get: (systemId) => {\n      return keyedActors.get(systemId) as T['actors'][any];\n    },\n    _set: (systemId, actorRef) => {\n      const existing = keyedActors.get(systemId);\n      if (existing && existing !== actorRef) {\n        throw new Error(\n          `Actor with system ID '${systemId as string}' already exists.`\n        );\n      }\n\n      keyedActors.set(systemId, actorRef);\n      reverseKeyedActors.set(actorRef, systemId);\n    },\n    inspect: (observerOrFn) => {\n      const observer = toObserver(observerOrFn);\n      inspectionObservers.add(observer);\n\n      return {\n        unsubscribe() {\n          inspectionObservers.delete(observer);\n        }\n      };\n    },\n    _sendInspectionEvent: sendInspectionEvent as any,\n    _relay: (source, target, event) => {\n      system._sendInspectionEvent({\n        type: '@xstate.event',\n        sourceRef: source,\n        actorRef: target,\n        event\n      });\n\n      target._send(event);\n    },\n    scheduler,\n    getSnapshot: () => {\n      return {\n        _scheduledEvents: { ...system._snapshot._scheduledEvents }\n      };\n    },\n    start: () => {\n      const scheduledEvents = system._snapshot._scheduledEvents;\n      system._snapshot._scheduledEvents = {};\n      for (const scheduledId in scheduledEvents) {\n        const { source, target, event, delay, id } =\n          scheduledEvents[scheduledId as ScheduledEventId];\n        scheduler.schedule(source, target, event, delay, id);\n      }\n    },\n    _clock: clock,\n    _logger: logger\n  };\n\n  return system;\n}\n","import isDevelopment from '#is-development';\nimport { Mailbox } from './Mailbox.ts';\nimport { XSTATE_STOP } from './constants.ts';\nimport { devToolsAdapter } from './dev/index.ts';\nimport {\n  createDoneActorEvent,\n  createErrorActorEvent,\n  createInitEvent\n} from './eventUtils.ts';\nimport { reportUnhandledError } from './reportUnhandledError.ts';\nimport { symbolObservable } from './symbolObservable.ts';\nimport { AnyActorSystem, Clock, createSystem } from './system.ts';\n\nimport type {\n  ActorScope,\n  AnyActorLogic,\n  AnyActorRef,\n  ConditionalRequired,\n  DoneActorEvent,\n  EmittedFrom,\n  EventFromLogic,\n  InputFrom,\n  IsNotNever,\n  Snapshot,\n  SnapshotFrom\n} from './types.ts';\nimport {\n  ActorOptions,\n  ActorRef,\n  EventObject,\n  InteropSubscribable,\n  Observer,\n  Subscription\n} from './types.ts';\nimport { toObserver } from './utils.ts';\n\nexport const $$ACTOR_TYPE = 1;\n\n// those values are currently used by @xstate/react directly so it's important to keep the assigned values in sync\nexport enum ProcessingStatus {\n  NotStarted = 0,\n  Running = 1,\n  Stopped = 2\n}\n\nconst defaultOptions = {\n  clock: {\n    setTimeout: (fn, ms) => {\n      return setTimeout(fn, ms);\n    },\n    clearTimeout: (id) => {\n      return clearTimeout(id);\n    }\n  } as Clock,\n  logger: console.log.bind(console),\n  devTools: false\n};\n\n/**\n * An Actor is a running process that can receive events, send events and change\n * its behavior based on the events it receives, which can cause effects outside\n * of the actor. When you run a state machine, it becomes an actor.\n */\nexport class Actor<TLogic extends AnyActorLogic>\n  implements\n    ActorRef<SnapshotFrom<TLogic>, EventFromLogic<TLogic>, EmittedFrom<TLogic>>\n{\n  /** The current internal state of the actor. */\n  private _snapshot!: SnapshotFrom<TLogic>;\n  /**\n   * The clock that is responsible for setting and clearing timeouts, such as\n   * delayed events and transitions.\n   */\n  public clock: Clock;\n  public options: Readonly<ActorOptions<TLogic>>;\n\n  /** The unique identifier for this actor relative to its parent. */\n  public id: string;\n\n  private mailbox: Mailbox<EventFromLogic<TLogic>> = new Mailbox(\n    this._process.bind(this)\n  );\n\n  private observers: Set<Observer<SnapshotFrom<TLogic>>> = new Set();\n  private eventListeners: Map<\n    string,\n    Set<(emittedEvent: EmittedFrom<TLogic>) => void>\n  > = new Map();\n  private logger: (...args: any[]) => void;\n\n  /** @internal */\n  public _processingStatus: ProcessingStatus = ProcessingStatus.NotStarted;\n\n  // Actor Ref\n  public _parent?: AnyActorRef;\n  /** @internal */\n  public _syncSnapshot?: boolean;\n  public ref: ActorRef<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    EmittedFrom<TLogic>\n  >;\n  // TODO: add typings for system\n  private _actorScope: ActorScope<\n    SnapshotFrom<TLogic>,\n    EventFromLogic<TLogic>,\n    AnyActorSystem,\n    EmittedFrom<TLogic>\n  >;\n\n  private _systemId: string | undefined;\n\n  /** The globally unique process ID for this invocation. */\n  public sessionId: string;\n\n  /** The system to which this actor belongs. */\n  public system: AnyActorSystem;\n  private _doneEvent?: DoneActorEvent;\n\n  public src: string | AnyActorLogic;\n\n  /**\n   * Creates a new actor instance for the given logic with the provided options,\n   * if any.\n   *\n   * @param logic The logic to create an actor from\n   * @param options Actor options\n   */\n  constructor(\n    public logic: TLogic,\n    options?: ActorOptions<TLogic>\n  ) {\n    const resolvedOptions = {\n      ...defaultOptions,\n      ...options\n    };\n\n    const { clock, logger, parent, syncSnapshot, id, systemId, inspect } =\n      resolvedOptions;\n\n    this.system = parent\n      ? parent.system\n      : createSystem(this, {\n          clock,\n          logger\n        });\n\n    if (inspect && !parent) {\n      // Always inspect at the system-level\n      this.system.inspect(toObserver(inspect));\n    }\n\n    this.sessionId = this.system._bookId();\n    this.id = id ?? this.sessionId;\n    this.logger = options?.logger ?? this.system._logger;\n    this.clock = options?.clock ?? this.system._clock;\n    this._parent = parent;\n    this._syncSnapshot = syncSnapshot;\n    this.options = resolvedOptions as ActorOptions<TLogic> &\n      typeof defaultOptions;\n    this.src = resolvedOptions.src ?? logic;\n    this.ref = this;\n    this._actorScope = {\n      self: this,\n      id: this.id,\n      sessionId: this.sessionId,\n      logger: this.logger,\n      defer: (fn) => {\n        this._deferred.push(fn);\n      },\n      system: this.system,\n      stopChild: (child) => {\n        if (child._parent !== this) {\n          throw new Error(\n            `Cannot stop child actor ${child.id} of ${this.id} because it is not a child`\n          );\n        }\n        (child as any)._stop();\n      },\n      emit: (emittedEvent) => {\n        const listeners = this.eventListeners.get(emittedEvent.type);\n        const wildcardListener = this.eventListeners.get('*');\n        if (!listeners && !wildcardListener) {\n          return;\n        }\n        const allListeners = new Set([\n          ...(listeners ? listeners.values() : []),\n          ...(wildcardListener ? wildcardListener.values() : [])\n        ]);\n        for (const handler of Array.from(allListeners)) {\n          handler(emittedEvent);\n        }\n      }\n    };\n\n    // Ensure that the send method is bound to this Actor instance\n    // if destructured\n    this.send = this.send.bind(this);\n    this.system._sendInspectionEvent({\n      type: '@xstate.actor',\n      actorRef: this\n    });\n\n    if (systemId) {\n      this._systemId = systemId;\n      this.system._set(systemId, this);\n    }\n\n    this._initState(options?.snapshot ?? options?.state);\n\n    if (systemId && (this._snapshot as any).status !== 'active') {\n      this.system._unregister(this);\n    }\n  }\n\n  private _initState(persistedState?: Snapshot<unknown>) {\n    try {\n      this._snapshot = persistedState\n        ? this.logic.restoreSnapshot\n          ? this.logic.restoreSnapshot(persistedState, this._actorScope)\n          : persistedState\n        : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);\n    } catch (err) {\n      // if we get here then it means that we assign a value to this._snapshot that is not of the correct type\n      // we can't get the true `TSnapshot & { status: 'error'; }`, it's impossible\n      // so right now this is a lie of sorts\n      this._snapshot = {\n        status: 'error',\n        output: undefined,\n        error: err\n      } as any;\n    }\n  }\n\n  // array of functions to defer\n  private _deferred: Array<() => void> = [];\n\n  private update(snapshot: SnapshotFrom<TLogic>, event: EventObject): void {\n    // Update state\n    this._snapshot = snapshot;\n\n    // Execute deferred effects\n    let deferredFn: (typeof this._deferred)[number] | undefined;\n\n    while ((deferredFn = this._deferred.shift())) {\n      try {\n        deferredFn();\n      } catch (err) {\n        // this error can only be caught when executing *initial* actions\n        // it's the only time when we call actions provided by the user through those deferreds\n        // when the actor is already running we always execute them synchronously while transitioning\n        // no \"builtin deferred\" should actually throw an error since they are either safe\n        // or the control flow is passed through the mailbox and errors should be caught by the `_process` used by the mailbox\n        this._deferred.length = 0;\n        this._snapshot = {\n          ...(snapshot as any),\n          status: 'error',\n          error: err\n        };\n      }\n    }\n\n    switch ((this._snapshot as any).status) {\n      case 'active':\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n        break;\n      case 'done':\n        // next observers are meant to be notified about done snapshots\n        // this can be seen as something that is different from how observable work\n        // but with observables `complete` callback is called without any arguments\n        // it's more ergonomic for XState to treat a done snapshot as a \"next\" value\n        // and the completion event as something that is separate,\n        // something that merely follows emitting that done snapshot\n        for (const observer of this.observers) {\n          try {\n            observer.next?.(snapshot);\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n        }\n\n        this._stopProcedure();\n        this._complete();\n        this._doneEvent = createDoneActorEvent(\n          this.id,\n          (this._snapshot as any).output\n        );\n        if (this._parent) {\n          this.system._relay(this, this._parent, this._doneEvent);\n        }\n\n        break;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        break;\n    }\n    this.system._sendInspectionEvent({\n      type: '@xstate.snapshot',\n      actorRef: this,\n      event,\n      snapshot\n    });\n  }\n\n  /**\n   * Subscribe an observer to an actor’s snapshot values.\n   *\n   * @remarks\n   * The observer will receive the actor’s snapshot value when it is emitted.\n   * The observer can be:\n   *\n   * - A plain function that receives the latest snapshot, or\n   * - An observer object whose `.next(snapshot)` method receives the latest\n   *   snapshot\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as a plain function\n   * const subscription = actor.subscribe((snapshot) => {\n   *   console.log(snapshot);\n   * });\n   * ```\n   *\n   * @example\n   *\n   * ```ts\n   * // Observer as an object\n   * const subscription = actor.subscribe({\n   *   next(snapshot) {\n   *     console.log(snapshot);\n   *   },\n   *   error(err) {\n   *     // ...\n   *   },\n   *   complete() {\n   *     // ...\n   *   }\n   * });\n   * ```\n   *\n   * The return value of `actor.subscribe(observer)` is a subscription object\n   * that has an `.unsubscribe()` method. You can call\n   * `subscription.unsubscribe()` to unsubscribe the observer:\n   *\n   * @example\n   *\n   * ```ts\n   * const subscription = actor.subscribe((snapshot) => {\n   *   // ...\n   * });\n   *\n   * // Unsubscribe the observer\n   * subscription.unsubscribe();\n   * ```\n   *\n   * When the actor is stopped, all of its observers will automatically be\n   * unsubscribed.\n   *\n   * @param observer - Either a plain function that receives the latest\n   *   snapshot, or an observer object whose `.next(snapshot)` method receives\n   *   the latest snapshot\n   */\n  public subscribe(observer: Observer<SnapshotFrom<TLogic>>): Subscription;\n  public subscribe(\n    nextListener?: (snapshot: SnapshotFrom<TLogic>) => void,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription;\n  public subscribe(\n    nextListenerOrObserver?:\n      | ((snapshot: SnapshotFrom<TLogic>) => void)\n      | Observer<SnapshotFrom<TLogic>>,\n    errorListener?: (error: any) => void,\n    completeListener?: () => void\n  ): Subscription {\n    const observer = toObserver(\n      nextListenerOrObserver,\n      errorListener,\n      completeListener\n    );\n\n    if (this._processingStatus !== ProcessingStatus.Stopped) {\n      this.observers.add(observer);\n    } else {\n      switch ((this._snapshot as any).status) {\n        case 'done':\n          try {\n            observer.complete?.();\n          } catch (err) {\n            reportUnhandledError(err);\n          }\n          break;\n        case 'error': {\n          const err = (this._snapshot as any).error;\n          if (!observer.error) {\n            reportUnhandledError(err);\n          } else {\n            try {\n              observer.error(err);\n            } catch (err) {\n              reportUnhandledError(err);\n            }\n          }\n          break;\n        }\n      }\n    }\n\n    return {\n      unsubscribe: () => {\n        this.observers.delete(observer);\n      }\n    };\n  }\n\n  public on<TType extends EmittedFrom<TLogic>['type'] | '*'>(\n    type: TType,\n    handler: (\n      emitted: EmittedFrom<TLogic> & (TType extends '*' ? {} : { type: TType })\n    ) => void\n  ): Subscription {\n    let listeners = this.eventListeners.get(type);\n    if (!listeners) {\n      listeners = new Set();\n      this.eventListeners.set(type, listeners);\n    }\n    const wrappedHandler = handler.bind(undefined);\n    listeners.add(wrappedHandler);\n\n    return {\n      unsubscribe: () => {\n        listeners!.delete(wrappedHandler);\n      }\n    };\n  }\n\n  /** Starts the Actor from the initial state */\n  public start(): this {\n    if (this._processingStatus === ProcessingStatus.Running) {\n      // Do not restart the service if it is already started\n      return this;\n    }\n\n    if (this._syncSnapshot) {\n      this.subscribe({\n        next: (snapshot: Snapshot<unknown>) => {\n          if (snapshot.status === 'active') {\n            this.system._relay(this, this._parent!, {\n              type: `xstate.snapshot.${this.id}`,\n              snapshot\n            });\n          }\n        },\n        error: () => {}\n      });\n    }\n\n    this.system._register(this.sessionId, this);\n    if (this._systemId) {\n      this.system._set(this._systemId, this);\n    }\n    this._processingStatus = ProcessingStatus.Running;\n\n    // TODO: this isn't correct when rehydrating\n    const initEvent = createInitEvent(this.options.input);\n\n    this.system._sendInspectionEvent({\n      type: '@xstate.event',\n      sourceRef: this._parent,\n      actorRef: this,\n      event: initEvent\n    });\n\n    const status = (this._snapshot as any).status;\n\n    switch (status) {\n      case 'done':\n        // a state machine can be \"done\" upon initialization (it could reach a final state using initial microsteps)\n        // we still need to complete observers, flush deferreds etc\n        this.update(\n          this._snapshot,\n          initEvent as unknown as EventFromLogic<TLogic>\n        );\n        // TODO: rethink cleanup of observers, mailbox, etc\n        return this;\n      case 'error':\n        this._error((this._snapshot as any).error);\n        return this;\n    }\n\n    if (!this._parent) {\n      this.system.start();\n    }\n\n    if (this.logic.start) {\n      try {\n        this.logic.start(this._snapshot, this._actorScope);\n      } catch (err) {\n        this._snapshot = {\n          ...(this._snapshot as any),\n          status: 'error',\n          error: err\n        };\n        this._error(err);\n        return this;\n      }\n    }\n\n    // TODO: this notifies all subscribers but usually this is redundant\n    // there is no real change happening here\n    // we need to rethink if this needs to be refactored\n    this.update(this._snapshot, initEvent as unknown as EventFromLogic<TLogic>);\n\n    if (this.options.devTools) {\n      this.attachDevTools();\n    }\n\n    this.mailbox.start();\n\n    return this;\n  }\n\n  private _process(event: EventFromLogic<TLogic>) {\n    let nextState;\n    let caughtError;\n    try {\n      nextState = this.logic.transition(\n        this._snapshot,\n        event,\n        this._actorScope\n      );\n    } catch (err) {\n      // we wrap it in a box so we can rethrow it later even if falsy value gets caught here\n      caughtError = { err };\n    }\n\n    if (caughtError) {\n      const { err } = caughtError;\n\n      this._snapshot = {\n        ...(this._snapshot as any),\n        status: 'error',\n        error: err\n      };\n      this._error(err);\n      return;\n    }\n\n    this.update(nextState, event);\n    if (event.type === XSTATE_STOP) {\n      this._stopProcedure();\n      this._complete();\n    }\n  }\n\n  private _stop(): this {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      return this;\n    }\n    this.mailbox.clear();\n    if (this._processingStatus === ProcessingStatus.NotStarted) {\n      this._processingStatus = ProcessingStatus.Stopped;\n      return this;\n    }\n    this.mailbox.enqueue({ type: XSTATE_STOP } as any);\n\n    return this;\n  }\n\n  /** Stops the Actor and unsubscribe all listeners. */\n  public stop(): this {\n    if (this._parent) {\n      throw new Error('A non-root actor cannot be stopped directly.');\n    }\n    return this._stop();\n  }\n  private _complete(): void {\n    for (const observer of this.observers) {\n      try {\n        observer.complete?.();\n      } catch (err) {\n        reportUnhandledError(err);\n      }\n    }\n    this.observers.clear();\n  }\n  private _reportError(err: unknown): void {\n    if (!this.observers.size) {\n      if (!this._parent) {\n        reportUnhandledError(err);\n      }\n      return;\n    }\n    let reportError = false;\n\n    for (const observer of this.observers) {\n      const errorListener = observer.error;\n      reportError ||= !errorListener;\n      try {\n        errorListener?.(err);\n      } catch (err2) {\n        reportUnhandledError(err2);\n      }\n    }\n    this.observers.clear();\n    if (reportError) {\n      reportUnhandledError(err);\n    }\n  }\n  private _error(err: unknown): void {\n    this._stopProcedure();\n    this._reportError(err);\n    if (this._parent) {\n      this.system._relay(\n        this,\n        this._parent,\n        createErrorActorEvent(this.id, err)\n      );\n    }\n  }\n  // TODO: atm children don't belong entirely to the actor so\n  // in a way - it's not even super aware of them\n  // so we can't stop them from here but we really should!\n  // right now, they are being stopped within the machine's transition\n  // but that could throw and leave us with \"orphaned\" active actors\n  private _stopProcedure(): this {\n    if (this._processingStatus !== ProcessingStatus.Running) {\n      // Actor already stopped; do nothing\n      return this;\n    }\n\n    // Cancel all delayed events\n    this.system.scheduler.cancelAll(this);\n\n    // TODO: mailbox.reset\n    this.mailbox.clear();\n    // TODO: after `stop` we must prepare ourselves for receiving events again\n    // events sent *after* stop signal must be queued\n    // it seems like this should be the common behavior for all of our consumers\n    // so perhaps this should be unified somehow for all of them\n    this.mailbox = new Mailbox(this._process.bind(this));\n\n    this._processingStatus = ProcessingStatus.Stopped;\n    this.system._unregister(this);\n\n    return this;\n  }\n\n  /** @internal */\n  public _send(event: EventFromLogic<TLogic>) {\n    if (this._processingStatus === ProcessingStatus.Stopped) {\n      // do nothing\n      if (isDevelopment) {\n        const eventString = JSON.stringify(event);\n\n        console.warn(\n          `Event \"${event.type}\" was sent to stopped actor \"${this.id} (${this.sessionId})\". This actor has already reached its final state, and will not transition.\\nEvent: ${eventString}`\n        );\n      }\n      return;\n    }\n\n    this.mailbox.enqueue(event);\n  }\n\n  /**\n   * Sends an event to the running Actor to trigger a transition.\n   *\n   * @param event The event to send\n   */\n  public send(event: EventFromLogic<TLogic>) {\n    if (isDevelopment && typeof event === 'string') {\n      throw new Error(\n        `Only event objects may be sent to actors; use .send({ type: \"${event}\" }) instead`\n      );\n    }\n    this.system._relay(undefined, this, event);\n  }\n\n  private attachDevTools(): void {\n    const { devTools } = this.options;\n    if (devTools) {\n      const resolvedDevToolsAdapter =\n        typeof devTools === 'function' ? devTools : devToolsAdapter;\n\n      resolvedDevToolsAdapter(this);\n    }\n  }\n  public toJSON() {\n    return {\n      xstate$$type: $$ACTOR_TYPE,\n      id: this.id\n    };\n  }\n\n  /**\n   * Obtain the internal state of the actor, which can be persisted.\n   *\n   * @remarks\n   * The internal state can be persisted from any actor, not only machines.\n   *\n   * Note that the persisted state is not the same as the snapshot from\n   * {@link Actor.getSnapshot}. Persisted state represents the internal state of\n   * the actor, while snapshots represent the actor's last emitted value.\n   *\n   * Can be restored with {@link ActorOptions.state}\n   * @see https://stately.ai/docs/persistence\n   */\n  public getPersistedSnapshot(): Snapshot<unknown>;\n  public getPersistedSnapshot(options?: unknown): Snapshot<unknown> {\n    return this.logic.getPersistedSnapshot(this._snapshot, options);\n  }\n\n  public [symbolObservable](): InteropSubscribable<SnapshotFrom<TLogic>> {\n    return this;\n  }\n\n  /**\n   * Read an actor’s snapshot synchronously.\n   *\n   * @remarks\n   * The snapshot represent an actor's last emitted value.\n   *\n   * When an actor receives an event, its internal state may change. An actor\n   * may emit a snapshot when a state transition occurs.\n   *\n   * Note that some actors, such as callback actors generated with\n   * `fromCallback`, will not emit snapshots.\n   * @see {@link Actor.subscribe} to subscribe to an actor’s snapshot values.\n   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).\n   */\n  public getSnapshot(): SnapshotFrom<TLogic> {\n    if (isDevelopment && !this._snapshot) {\n      throw new Error(\n        `Snapshot can't be read while the actor initializes itself`\n      );\n    }\n    return this._snapshot;\n  }\n}\n\nexport type RequiredActorOptionsKeys<TLogic extends AnyActorLogic> =\n  undefined extends InputFrom<TLogic> ? never : 'input';\n\n/**\n * Creates a new actor instance for the given actor logic with the provided\n * options, if any.\n *\n * @remarks\n * When you create an actor from actor logic via `createActor(logic)`, you\n * implicitly create an actor system where the created actor is the root actor.\n * Any actors spawned from this root actor and its descendants are part of that\n * actor system.\n * @example\n *\n * ```ts\n * import { createActor } from 'xstate';\n * import { someActorLogic } from './someActorLogic.ts';\n *\n * // Creating the actor, which implicitly creates an actor system with itself as the root actor\n * const actor = createActor(someActorLogic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n *\n * // Actors must be started by calling `actor.start()`, which will also start the actor system.\n * actor.start();\n *\n * // Actors can receive events\n * actor.send({ type: 'someEvent' });\n *\n * // You can stop root actors by calling `actor.stop()`, which will also stop the actor system and all actors in that system.\n * actor.stop();\n * ```\n *\n * @param logic - The actor logic to create an actor from. For a state machine\n *   actor logic creator, see {@link createMachine}. Other actor logic creators\n *   include {@link fromCallback}, {@link fromEventObservable},\n *   {@link fromObservable}, {@link fromPromise}, and {@link fromTransition}.\n * @param options - Actor options\n */\nexport function createActor<TLogic extends AnyActorLogic>(\n  logic: TLogic,\n  ...[options]: ConditionalRequired<\n    [\n      options?: ActorOptions<TLogic> & {\n        [K in RequiredActorOptionsKeys<TLogic>]: unknown;\n      }\n    ],\n    IsNotNever<RequiredActorOptionsKeys<TLogic>>\n  >\n): Actor<TLogic> {\n  return new Actor(logic, options);\n}\n\n/**\n * Creates a new Interpreter instance for the given machine with the provided\n * options, if any.\n *\n * @deprecated Use `createActor` instead\n * @alias\n */\nexport const interpret = createActor;\n\n/**\n * @deprecated Use `Actor` instead.\n * @alias\n */\nexport type Interpreter = typeof Actor;\n","import { XSTATE_INIT } from './constants.ts';\nimport { DoneActorEvent, DoneStateEvent, ErrorActorEvent } from './types.ts';\n\n/**\n * Returns an event that represents an implicit event that is sent after the\n * specified `delay`.\n *\n * @param delayRef The delay in milliseconds\n * @param id The state node ID where this event is handled\n */\nexport function createAfterEvent(delayRef: number | string, id: string) {\n  return { type: `xstate.after.${delayRef}.${id}` } as const;\n}\n\n/**\n * Returns an event that represents that a final state node has been reached in\n * the parent state node.\n *\n * @param id The final state node's parent state node `id`\n * @param output The data to pass into the event\n */\nexport function createDoneStateEvent(\n  id: string,\n  output?: unknown\n): DoneStateEvent {\n  return {\n    type: `xstate.done.state.${id}`,\n    output\n  };\n}\n\n/**\n * Returns an event that represents that an invoked service has terminated.\n *\n * An invoked service is terminated when it has reached a top-level final state\n * node, but not when it is canceled.\n *\n * @param invokeId The invoked service ID\n * @param output The data to pass into the event\n */\nexport function createDoneActorEvent(\n  invokeId: string,\n  output?: unknown\n): DoneActorEvent {\n  return {\n    type: `xstate.done.actor.${invokeId}`,\n    output,\n    actorId: invokeId\n  };\n}\n\nexport function createErrorActorEvent(\n  id: string,\n  error?: unknown\n): ErrorActorEvent {\n  return { type: `xstate.error.actor.${id}`, error, actorId: id };\n}\n\nexport function createInitEvent(input: unknown) {\n  return { type: XSTATE_INIT, input } as const;\n}\n","import { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  ActorScope,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type TransitionSnapshot<TContext> = Snapshot<undefined> & {\n  context: TContext;\n};\n\nexport type TransitionActorLogic<\n  TContext,\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  TransitionSnapshot<TContext>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromTransition`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromTransition,\n *   createActor,\n *   type AnyActorSystem\n * } from 'xstate';\n *\n * //* The actor's stored context.\n * type Context = {\n *   // The current count.\n *   count: number;\n *   // The amount to increase `count` by.\n *   step: number;\n * };\n * // The events the actor receives.\n * type Event = { type: 'increment' };\n * // The actor's input.\n * type Input = { step?: number };\n *\n * // Actor logic that increments `count` by `step` when it receives an event of\n * // type `increment`.\n * const logic = fromTransition<Context, Event, AnyActorSystem, Input>(\n *   (state, event, actorScope) => {\n *     actorScope.self;\n *     //         ^? TransitionActorRef<Context, Event>\n *\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + state.step\n *       };\n *     }\n *     return state;\n *   },\n *   ({ input, self }) => {\n *     self;\n *     // ^? TransitionActorRef<Context, Event>\n *\n *     return {\n *       count: 0,\n *       step: input.step ?? 1\n *     };\n *   }\n * );\n *\n * const actor = createActor(logic, { input: { step: 10 } });\n * //    ^? TransitionActorRef<Context, Event>\n * ```\n *\n * @see {@link fromTransition}\n */\nexport type TransitionActorRef<\n  TContext,\n  TEvent extends EventObject\n> = ActorRefFromLogic<\n  TransitionActorLogic<TransitionSnapshot<TContext>, TEvent, unknown>\n>;\n\n/**\n * Returns actor logic given a transition function and its initial state.\n *\n * A “transition function” is a function that takes the current `state` and\n * received `event` object as arguments, and returns the next state, similar to\n * a reducer.\n *\n * Actors created from transition logic (“transition actors”) can:\n *\n * - Receive events\n * - Emit snapshots of its state\n *\n * The transition function’s `state` is used as its transition actor’s\n * `context`.\n *\n * Note that the \"state\" for a transition function is provided by the initial\n * state argument, and is not the same as the State object of an actor or a\n * state within a machine configuration.\n *\n * @example\n *\n * ```ts\n * const transitionLogic = fromTransition(\n *   (state, event) => {\n *     if (event.type === 'increment') {\n *       return {\n *         ...state,\n *         count: state.count + 1\n *       };\n *     }\n *     return state;\n *   },\n *   { count: 0 }\n * );\n *\n * const transitionActor = createActor(transitionLogic);\n * transitionActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * transitionActor.start();\n * // => {\n * //   status: 'active',\n * //   context: { count: 0 },\n * //   ...\n * // }\n *\n * transitionActor.send({ type: 'increment' });\n * // => {\n * //   status: 'active',\n * //   context: { count: 1 },\n * //   ...\n * // }\n * ```\n *\n * @param transition The transition function used to describe the transition\n *   logic. It should return the next state given the current state and event.\n *   It receives the following arguments:\n *\n *   - `state` - the current state.\n *   - `event` - the received event.\n *   - `actorScope` - the actor scope object, with properties like `self` and\n *       `system`.\n *\n * @param initialContext The initial state of the transition function, either an\n *   object representing the state, or a function which returns a state object.\n *   If a function, it will receive as its only argument an object with the\n *   following properties:\n *\n *   - `input` - the `input` provided to its parent transition actor.\n *   - `self` - a reference to its parent transition actor.\n *\n * @returns Actor logic\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromTransition<\n  TContext,\n  TEvent extends EventObject,\n  TSystem extends AnyActorSystem,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  transition: (\n    snapshot: TContext,\n    event: TEvent,\n    actorScope: ActorScope<\n      TransitionSnapshot<TContext>,\n      TEvent,\n      TSystem,\n      TEmitted\n    >\n  ) => TContext,\n  initialContext:\n    | TContext\n    | (({\n        input,\n        self\n      }: {\n        input: TInput;\n        self: TransitionActorRef<TContext, TEvent>;\n      }) => TContext) // TODO: type\n): TransitionActorLogic<TContext, TEvent, TInput, TEmitted> {\n  return {\n    config: transition,\n    transition: (snapshot, event, actorScope) => {\n      return {\n        ...snapshot,\n        context: transition(\n          snapshot.context,\n          event as TEvent,\n          actorScope as any\n        )\n      };\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context:\n          typeof initialContext === 'function'\n            ? (initialContext as any)({ input })\n            : initialContext\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  AnyActorRef,\n  AnyEventObject,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types';\n\ninterface CallbackInstanceState<TEvent extends EventObject> {\n  receivers: Set<(e: TEvent) => void> | undefined;\n  dispose: (() => void) | void;\n}\n\nconst instanceStates = /* #__PURE__ */ new WeakMap<\n  AnyActorRef,\n  CallbackInstanceState<any>\n>();\n\nexport type CallbackSnapshot<TInput> = Snapshot<undefined> & {\n  input: TInput;\n};\n\nexport type CallbackActorLogic<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  CallbackSnapshot<TInput>,\n  TEvent,\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromCallback`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromCallback, createActor } from 'xstate';\n *\n * // The events the actor receives.\n * type Event = { type: 'someEvent' };\n * // The actor's input.\n * type Input = { name: string };\n *\n * // Actor logic that logs whenever it receives an event of type `someEvent`.\n * const logic = fromCallback<Event, Input>(({ self, input, receive }) => {\n *   self;\n *   // ^? CallbackActorRef<Event, Input>\n *\n *   receive((event) => {\n *     if (event.type === 'someEvent') {\n *       console.log(`${input.name}: received \"someEvent\" event`);\n *       // logs 'myActor: received \"someEvent\" event'\n *     }\n *   });\n * });\n *\n * const actor = createActor(logic, { input: { name: 'myActor' } });\n * //    ^? CallbackActorRef<Event, Input>\n * ```\n *\n * @see {@link fromCallback}\n */\nexport type CallbackActorRef<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown\n> = ActorRefFromLogic<CallbackActorLogic<TEvent, TInput>>;\n\ntype Receiver<TEvent extends EventObject> = (\n  listener: {\n    bivarianceHack(event: TEvent): void;\n  }['bivarianceHack']\n) => void;\n\nexport type CallbackLogicFunction<\n  TEvent extends EventObject = AnyEventObject,\n  TSentEvent extends EventObject = AnyEventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ({\n  input,\n  system,\n  self,\n  sendBack,\n  receive,\n  emit\n}: {\n  /**\n   * Data that was provided to the callback actor\n   *\n   * @see {@link https://stately.ai/docs/input | Input docs}\n   */\n  input: TInput;\n  /** The actor system to which the callback actor belongs */\n  system: AnyActorSystem;\n  /** The parent actor of the callback actor */\n  self: CallbackActorRef<TEvent>;\n  /** A function that can send events back to the parent actor */\n  sendBack: (event: TSentEvent) => void;\n  /**\n   * A function that can be called with a listener function argument; the\n   * listener is then called whenever events are received by the callback actor\n   */\n  receive: Receiver<TEvent>;\n  emit: (emitted: TEmitted) => void;\n}) => (() => void) | void;\n\n/**\n * An actor logic creator which returns callback logic as defined by a callback\n * function.\n *\n * @remarks\n * Useful for subscription-based or other free-form logic that can send events\n * back to the parent actor.\n *\n * Actors created from callback logic (“callback actors”) can:\n *\n * - Receive events via the `receive` function\n * - Send events to the parent actor via the `sendBack` function\n *\n * Callback actors are a bit different from other actors in that they:\n *\n * - Do not work with `onDone`\n * - Do not produce a snapshot using `.getSnapshot()`\n * - Do not emit values when used with `.subscribe()`\n * - Can not be stopped with `.stop()`\n *\n * @example\n *\n * ```typescript\n * const callbackLogic = fromCallback(({ sendBack, receive }) => {\n *   let lockStatus = 'unlocked';\n *\n *   const handler = (event) => {\n *     if (lockStatus === 'locked') {\n *       return;\n *     }\n *     sendBack(event);\n *   };\n *\n *   receive((event) => {\n *     if (event.type === 'lock') {\n *       lockStatus = 'locked';\n *     } else if (event.type === 'unlock') {\n *       lockStatus = 'unlocked';\n *     }\n *   });\n *\n *   document.body.addEventListener('click', handler);\n *\n *   return () => {\n *     document.body.removeEventListener('click', handler);\n *   };\n * });\n * ```\n *\n * @param callback - The callback function used to describe the callback logic\n *   The callback function is passed an object with the following properties:\n *\n *   - `receive` - A function that can send events back to the parent actor; the\n *       listener is then called whenever events are received by the callback\n *       actor\n *   - `sendBack` - A function that can send events back to the parent actor\n *   - `input` - Data that was provided to the callback actor\n *   - `self` - The parent actor of the callback actor\n *   - `system` - The actor system to which the callback actor belongs The callback\n *       function can (optionally) return a cleanup function, which is called\n *       when the actor is stopped.\n *\n * @returns Callback logic\n * @see {@link CallbackLogicFunction} for more information about the callback function and its object argument\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromCallback<\n  TEvent extends EventObject,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  callback: CallbackLogicFunction<TEvent, AnyEventObject, TInput, TEmitted>\n): CallbackActorLogic<TEvent, TInput, TEmitted> {\n  const logic: CallbackActorLogic<TEvent, TInput, TEmitted> = {\n    config: callback,\n    start: (state, actorScope) => {\n      const { self, system, emit } = actorScope;\n\n      const callbackState: CallbackInstanceState<TEvent> = {\n        receivers: undefined,\n        dispose: undefined\n      };\n\n      instanceStates.set(self, callbackState);\n\n      callbackState.dispose = callback({\n        input: state.input,\n        system,\n        self,\n        sendBack: (event) => {\n          if (self.getSnapshot().status === 'stopped') {\n            return;\n          }\n          if (self._parent) {\n            system._relay(self, self._parent, event);\n          }\n        },\n        receive: (listener) => {\n          callbackState.receivers ??= new Set();\n          callbackState.receivers.add(listener);\n        },\n        emit\n      });\n    },\n    transition: (state, event, actorScope) => {\n      const callbackState: CallbackInstanceState<TEvent> = instanceStates.get(\n        actorScope.self\n      )!;\n\n      if (event.type === XSTATE_STOP) {\n        state = {\n          ...state,\n          status: 'stopped',\n          error: undefined\n        };\n\n        callbackState.dispose?.();\n        return state;\n      }\n\n      callbackState.receivers?.forEach((receiver) => receiver(event));\n\n      return state;\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot,\n  Subscribable,\n  Subscription\n} from '../types';\n\nconst XSTATE_OBSERVABLE_NEXT = 'xstate.observable.next';\nconst XSTATE_OBSERVABLE_ERROR = 'xstate.observable.error';\nconst XSTATE_OBSERVABLE_COMPLETE = 'xstate.observable.complete';\n\nexport type ObservableSnapshot<\n  TContext,\n  TInput extends NonReducibleUnknown\n> = Snapshot<undefined> & {\n  context: TContext | undefined;\n  input: TInput | undefined;\n  _subscription: Subscription | undefined;\n};\n\nexport type ObservableActorLogic<\n  TContext,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  ObservableSnapshot<TContext, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput,\n  AnyActorSystem,\n  TEmitted\n>;\n\n/**\n * Represents an actor created by `fromObservable` or `fromEventObservable`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * // The type of the value observed by the actor's logic.\n * type Context = number;\n * // The actor's input.\n * type Input = { period?: number };\n *\n * // Actor logic that observes a number incremented every `input.period`\n * // milliseconds (default: 1_000).\n * const logic = fromObservable<Context, Input>(({ input, self }) => {\n *   self;\n *   // ^? ObservableActorRef<Event, Input>\n *\n *   return interval(input.period ?? 1_000);\n * });\n *\n * const actor = createActor(logic, { input: { period: 2_000 } });\n * //    ^? ObservableActorRef<Event, Input>\n * ```\n *\n * @see {@link fromObservable}\n * @see {@link fromEventObservable}\n */\nexport type ObservableActorRef<TContext> = ActorRefFromLogic<\n  ObservableActorLogic<TContext, any>\n>;\n\n/**\n * Observable actor logic is described by an observable stream of values. Actors\n * created from observable logic (“observable actors”) can:\n *\n * - Emit snapshots of the observable’s emitted value\n *\n * The observable’s emitted value is used as its observable actor’s `context`.\n *\n * Sending events to observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import { fromObservable, createActor } from 'xstate';\n * import { interval } from 'rxjs';\n *\n * const logic = fromObservable((obj) => interval(1000));\n *\n * const actor = createActor(logic);\n *\n * actor.subscribe((snapshot) => {\n *   console.log(snapshot.context);\n * });\n *\n * actor.start();\n * // At every second:\n * // Logs 0\n * // Logs 1\n * // Logs 2\n * // ...\n * ```\n *\n * @param observableCreator A function that creates an observable. It receives\n *   one argument, an object with the following properties:\n *\n *   - `input` - Data that was provided to the observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the observable actor belongs\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n * @see {@link https://rxjs.dev} for documentation on RxJS Observable and observable creators.\n * @see {@link Subscribable} interface in XState, which is based on and compatible with RxJS Observable.\n */\nexport function fromObservable<\n  TContext,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  observableCreator: ({\n    input,\n    system,\n    self\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TContext>;\n    emit: (emitted: TEmitted) => void;\n  }) => Subscribable<TContext>\n): ObservableActorLogic<TContext, TInput, TEmitted> {\n  // TODO: add event types\n  const logic: ObservableActorLogic<TContext, TInput, TEmitted> = {\n    config: observableCreator,\n    transition: (snapshot, event) => {\n      if (snapshot.status !== 'active') {\n        return snapshot;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_NEXT: {\n          const newSnapshot = {\n            ...snapshot,\n            context: event.data as TContext\n          };\n          return newSnapshot;\n        }\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...snapshot,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...snapshot,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          snapshot._subscription!.unsubscribe();\n          return {\n            ...snapshot,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return snapshot;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system, emit }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n      state._subscription = observableCreator({\n        input: state.input!,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: (value) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_NEXT,\n            data: value\n          });\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...state }) => state,\n    restoreSnapshot: (state) => ({\n      ...(state as any),\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n\n/**\n * Creates event observable logic that listens to an observable that delivers\n * event objects.\n *\n * Event observable actor logic is described by an observable stream of\n * {@link https://stately.ai/docs/transitions#event-objects | event objects}.\n * Actors created from event observable logic (“event observable actors”) can:\n *\n * - Implicitly send events to its parent actor\n * - Emit snapshots of its emitted event objects\n *\n * Sending events to event observable actors will have no effect.\n *\n * @example\n *\n * ```ts\n * import {\n *   fromEventObservable,\n *   Subscribable,\n *   EventObject,\n *   createMachine,\n *   createActor\n * } from 'xstate';\n * import { fromEvent } from 'rxjs';\n *\n * const mouseClickLogic = fromEventObservable(\n *   () => fromEvent(document.body, 'click') as Subscribable<EventObject>\n * );\n *\n * const canvasMachine = createMachine({\n *   invoke: {\n *     // Will send mouse `click` events to the canvas actor\n *     src: mouseClickLogic\n *   }\n * });\n *\n * const canvasActor = createActor(canvasMachine);\n * canvasActor.start();\n * ```\n *\n * @param lazyObservable A function that creates an observable that delivers\n *   event objects. It receives one argument, an object with the following\n *   properties:\n *\n *   - `input` - Data that was provided to the event observable actor\n *   - `self` - The parent actor\n *   - `system` - The actor system to which the event observable actor belongs.\n *\n *   It should return a {@link Subscribable}, which is compatible with an RxJS\n *   Observable, although RxJS is not required to create them.\n */\nexport function fromEventObservable<\n  TEvent extends EventObject,\n  TInput extends NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  lazyObservable: ({\n    input,\n    system,\n    self,\n    emit\n  }: {\n    input: TInput;\n    system: AnyActorSystem;\n    self: ObservableActorRef<TEvent>;\n    emit: (emitted: TEmitted) => void;\n  }) => Subscribable<TEvent>\n): ObservableActorLogic<TEvent, TInput, TEmitted> {\n  // TODO: event types\n  const logic: ObservableActorLogic<TEvent, TInput, TEmitted> = {\n    config: lazyObservable,\n    transition: (state, event) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_OBSERVABLE_ERROR:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_OBSERVABLE_COMPLETE:\n          return {\n            ...state,\n            status: 'done',\n            input: undefined,\n            _subscription: undefined\n          };\n        case XSTATE_STOP:\n          state._subscription!.unsubscribe();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined,\n            _subscription: undefined\n          };\n        default:\n          return state;\n      }\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        context: undefined,\n        input,\n        _subscription: undefined\n      };\n    },\n    start: (state, { self, system, emit }) => {\n      if (state.status === 'done') {\n        // Do not restart a completed observable\n        return;\n      }\n\n      state._subscription = lazyObservable({\n        input: state.input!,\n        system,\n        self,\n        emit\n      }).subscribe({\n        next: (value) => {\n          if (self._parent) {\n            system._relay(self, self._parent, value);\n          }\n        },\n        error: (err) => {\n          system._relay(self, self, {\n            type: XSTATE_OBSERVABLE_ERROR,\n            data: err\n          });\n        },\n        complete: () => {\n          system._relay(self, self, { type: XSTATE_OBSERVABLE_COMPLETE });\n        }\n      });\n    },\n    getPersistedSnapshot: ({ _subscription, ...snapshot }) => snapshot,\n    restoreSnapshot: (snapshot: any) => ({\n      ...snapshot,\n      _subscription: undefined\n    })\n  };\n\n  return logic;\n}\n","import { XSTATE_STOP } from '../constants.ts';\nimport { AnyActorSystem } from '../system.ts';\nimport {\n  ActorLogic,\n  ActorRefFromLogic,\n  AnyActorRef,\n  EventObject,\n  NonReducibleUnknown,\n  Snapshot\n} from '../types.ts';\n\nexport type PromiseSnapshot<TOutput, TInput> = Snapshot<TOutput> & {\n  input: TInput | undefined;\n};\n\nconst XSTATE_PROMISE_RESOLVE = 'xstate.promise.resolve';\nconst XSTATE_PROMISE_REJECT = 'xstate.promise.reject';\n\nexport type PromiseActorLogic<\n  TOutput,\n  TInput = unknown,\n  TEmitted extends EventObject = EventObject\n> = ActorLogic<\n  PromiseSnapshot<TOutput, TInput>,\n  { type: string; [k: string]: unknown },\n  TInput, // input\n  AnyActorSystem,\n  TEmitted // TEmitted\n>;\n\n/**\n * Represents an actor created by `fromPromise`.\n *\n * The type of `self` within the actor's logic.\n *\n * @example\n *\n * ```ts\n * import { fromPromise, createActor } from 'xstate';\n *\n * // The actor's resolved output\n * type Output = string;\n * // The actor's input.\n * type Input = { message: string };\n *\n * // Actor logic that fetches the url of an image of a cat saying `input.message`.\n * const logic = fromPromise<Output, Input>(async ({ input, self }) => {\n *   self;\n *   // ^? PromiseActorRef<Output, Input>\n *\n *   const data = await fetch(\n *     `https://cataas.com/cat/says/${input.message}`\n *   );\n *   const url = await data.json();\n *   return url;\n * });\n *\n * const actor = createActor(logic, { input: { message: 'hello world' } });\n * //    ^? PromiseActorRef<Output, Input>\n * ```\n *\n * @see {@link fromPromise}\n */\nexport type PromiseActorRef<TOutput> = ActorRefFromLogic<\n  PromiseActorLogic<TOutput, unknown>\n>;\n\nconst controllerMap = new WeakMap<AnyActorRef, AbortController>();\n\n/**\n * An actor logic creator which returns promise logic as defined by an async\n * process that resolves or rejects after some time.\n *\n * Actors created from promise actor logic (“promise actors”) can:\n *\n * - Emit the resolved value of the promise\n * - Output the resolved value of the promise\n *\n * Sending events to promise actors will have no effect.\n *\n * @example\n *\n * ```ts\n * const promiseLogic = fromPromise(async () => {\n *   const result = await fetch('https://example.com/...').then((data) =>\n *     data.json()\n *   );\n *\n *   return result;\n * });\n *\n * const promiseActor = createActor(promiseLogic);\n * promiseActor.subscribe((snapshot) => {\n *   console.log(snapshot);\n * });\n * promiseActor.start();\n * // => {\n * //   output: undefined,\n * //   status: 'active'\n * //   ...\n * // }\n *\n * // After promise resolves\n * // => {\n * //   output: { ... },\n * //   status: 'done',\n * //   ...\n * // }\n * ```\n *\n * @param promiseCreator A function which returns a Promise, and accepts an\n *   object with the following properties:\n *\n *   - `input` - Data that was provided to the promise actor\n *   - `self` - The parent actor of the promise actor\n *   - `system` - The actor system to which the promise actor belongs\n *\n * @see {@link https://stately.ai/docs/input | Input docs} for more information about how input is passed\n */\nexport function fromPromise<\n  TOutput,\n  TInput = NonReducibleUnknown,\n  TEmitted extends EventObject = EventObject\n>(\n  promiseCreator: ({\n    input,\n    system,\n    self,\n    signal,\n    emit\n  }: {\n    /** Data that was provided to the promise actor */\n    input: TInput;\n    /** The actor system to which the promise actor belongs */\n    system: AnyActorSystem;\n    /** The parent actor of the promise actor */\n    self: PromiseActorRef<TOutput>;\n    signal: AbortSignal;\n    emit: (emitted: TEmitted) => void;\n  }) => PromiseLike<TOutput>\n): PromiseActorLogic<TOutput, TInput, TEmitted> {\n  const logic: PromiseActorLogic<TOutput, TInput, TEmitted> = {\n    config: promiseCreator,\n    transition: (state, event, scope) => {\n      if (state.status !== 'active') {\n        return state;\n      }\n\n      switch (event.type) {\n        case XSTATE_PROMISE_RESOLVE: {\n          const resolvedValue = (event as any).data;\n          return {\n            ...state,\n            status: 'done',\n            output: resolvedValue,\n            input: undefined\n          };\n        }\n        case XSTATE_PROMISE_REJECT:\n          return {\n            ...state,\n            status: 'error',\n            error: (event as any).data,\n            input: undefined\n          };\n        case XSTATE_STOP: {\n          controllerMap.get(scope.self)?.abort();\n          return {\n            ...state,\n            status: 'stopped',\n            input: undefined\n          };\n        }\n        default:\n          return state;\n      }\n    },\n    start: (state, { self, system, emit }) => {\n      // TODO: determine how to allow customizing this so that promises\n      // can be restarted if necessary\n      if (state.status !== 'active') {\n        return;\n      }\n      const controller = new AbortController();\n      controllerMap.set(self, controller);\n      const resolvedPromise = Promise.resolve(\n        promiseCreator({\n          input: state.input!,\n          system,\n          self,\n          signal: controller.signal,\n          emit\n        })\n      );\n\n      resolvedPromise.then(\n        (response) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          controllerMap.delete(self);\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_RESOLVE,\n            data: response\n          });\n        },\n        (errorData) => {\n          if (self.getSnapshot().status !== 'active') {\n            return;\n          }\n          controllerMap.delete(self);\n          system._relay(self, self, {\n            type: XSTATE_PROMISE_REJECT,\n            data: errorData\n          });\n        }\n      );\n    },\n    getInitialSnapshot: (_, input) => {\n      return {\n        status: 'active',\n        output: undefined,\n        error: undefined,\n        input\n      };\n    },\n    getPersistedSnapshot: (snapshot) => snapshot,\n    restoreSnapshot: (snapshot: any) => snapshot\n  };\n\n  return logic;\n}\n","import { createActor } from '../createActor.ts';\nimport type { ActorRef, AnyEventObject, Snapshot } from '../types.ts';\nimport { fromTransition } from './transition.ts';\nexport {\n  fromCallback,\n  type CallbackActorLogic,\n  type CallbackActorRef,\n  type CallbackSnapshot,\n  type CallbackLogicFunction\n} from './callback.ts';\nexport {\n  fromEventObservable,\n  fromObservable,\n  type ObservableActorLogic,\n  type ObservableActorRef,\n  type ObservableSnapshot\n} from './observable.ts';\nexport {\n  fromPromise,\n  type PromiseActorLogic,\n  type PromiseActorRef,\n  type PromiseSnapshot\n} from './promise.ts';\nexport {\n  fromTransition,\n  type TransitionActorLogic,\n  type TransitionActorRef,\n  type TransitionSnapshot\n} from './transition.ts';\n\nconst emptyLogic = fromTransition((_) => undefined, undefined);\n\nexport function createEmptyActor(): ActorRef<\n  Snapshot<undefined>,\n  AnyEventObject,\n  AnyEventObject\n> {\n  return createActor(emptyLogic);\n}\n"],"names":["Mailbox","constructor","_process","this","_active","_current","_last","start","flush","clear","next","enqueue","event","enqueued","value","consumed","XSTATE_STOP","getDevTools","w","globalThis","self","window","__xstate__","devToolsAdapter","service","devTools","register","reportUnhandledError","err","setTimeout","symbolObservable","Symbol","observable","toObserver","nextHandler","errorHandler","completionHandler","isObserver","undefined","bind","error","complete","createScheduledEventId","actorRef","id","sessionId","idCounter","ProcessingStatus","defaultOptions","clock","fn","ms","clearTimeout","logger","console","log","Actor","logic","options","_snapshot","mailbox","observers","Set","eventListeners","Map","_processingStatus","NotStarted","_parent","_syncSnapshot","ref","_actorScope","_systemId","system","_doneEvent","src","_deferred","resolvedOptions","parent","syncSnapshot","systemId","inspect","rootActor","children","keyedActors","reverseKeyedActors","WeakMap","inspectionObservers","timerMap","scheduler","schedule","source","target","delay","Math","random","toString","slice","scheduledEvent","startedAt","Date","now","scheduledEventId","_scheduledEvents","timeout","_relay","cancel","cancelAll","snapshot","_bookId","_register","set","_unregister","delete","get","_set","existing","Error","observerOrFn","observer","add","unsubscribe","_sendInspectionEvent","size","resolvedInspectionEvent","rootId","forEach","type","sourceRef","_send","getSnapshot","scheduledEvents","scheduledId","_clock","_logger","createSystem","defer","push","stopChild","child","_stop","emit","emittedEvent","listeners","wildcardListener","allListeners","values","handler","Array","from","send","_initState","state","status","persistedState","restoreSnapshot","getInitialSnapshot","input","output","update","deferredFn","shift","length","_stopProcedure","_complete","invokeId","actorId","_error","subscribe","nextListenerOrObserver","errorListener","completeListener","Stopped","on","wrappedHandler","Running","initEvent","attachDevTools","nextState","caughtError","transition","stop","_reportError","reportError","err2","toJSON","xstate$$type","getPersistedSnapshot","fromTransition","initialContext","config","actorScope","context","_","instanceStates","XSTATE_OBSERVABLE_NEXT","XSTATE_OBSERVABLE_ERROR","XSTATE_OBSERVABLE_COMPLETE","XSTATE_PROMISE_RESOLVE","XSTATE_PROMISE_REJECT","controllerMap","emptyLogic","createActor","callback","callbackState","receivers","dispose","sendBack","receive","listener","receiver","lazyObservable","data","_subscription","observableCreator","promiseCreator","scope","resolvedValue","abort","controller","AbortController","Promise","resolve","signal","then","response","errorData"],"mappings":"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"}